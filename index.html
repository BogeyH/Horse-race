Here’s the full single-file build with the lane spread fix (responsive spacing, real inner width, minimum gap in px) and the label offset bump. Save as index.html.

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Photo Finish — Horse Race Multiplayer Betting</title>

<!--
  Photo Finish — Single-file build (with widened lanes)
  - Navy / cream / red theme
  - Players: 2–6 local
  - Randomized horses, stats, odds
  - Duplicate picks allowed
  - 3s countdown, gates open
  - Race runs top -> bottom ~20s
  - Leader-follow camera
  - Responsive lane spread (fixed)
  - Horizontal distance marks + vertical lane guides
  - Player colors + initials on horses
  - Galloping animation
  - Photo Finish slow-mo if close
  - Confetti + crowd cheer only if someone backed the winner (auto-fades in 5s)
  - Track lines fade for results
  - Results lock exactly on crossing
  - Manual Next Race
  - All CSS + JS inline
  - Sounds generated offline and embedded as Base64 WAV at runtime (small, no deps)
-->

<style>
  :root{
    /* Theme */
    --navy:#0B1F2A;
    --cream:#FDF5D9;
    --red:#D43D3D;
    --ink:#EDE6CB;
    --card:#102636;
    --track:#0E2230;

    /* Fixed lane colors (6) */
    --lane1:#FF9999;
    --lane2:#99CCFF;
    --lane3:#99FF99;
    --lane4:#FFCC99;
    --lane5:#CCCCFF;
    --lane6:#FFFF99;

    /* Sizes */
    --horse-w:44px;
    --horse-h:36px;
    --label-gap:8px;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background:var(--navy);
    color:var(--ink);
    overflow-x:hidden;
  }
  h1,h2,h3{margin:0 0 .5rem}
  .wrap{max-width:1000px;margin:0 auto;padding:14px 14px 90px}
  .grid{display:grid;gap:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .card{background:var(--card);border:1px solid #1e3a4a;border-radius:14px;padding:14px}
  .cta{background:var(--red);color:#fff;border:0;border-radius:12px;padding:12px 16px;font-weight:700;cursor:pointer}
  .cta[disabled]{opacity:.5;cursor:not-allowed}
  .ghost{background:transparent;border:1px solid #294757;color:#d3e1ea;border-radius:12px;padding:10px 14px;cursor:pointer}
  .pill{background:#123042;color:var(--ink);border:1px solid #22465b;border-radius:999px;padding:6px 10px;font-size:.9rem}
  .label{font-size:.85rem;color:#b6c6d2}
  .input{width:100%;background:#0d2230;color:var(--ink);border:1px solid #254b61;border-radius:10px;padding:10px}
  .kpi{display:flex;align-items:center;justify-content:space-between;background:#0f2636;border:1px solid #22465b;border-radius:12px;padding:10px 12px}
  .badge{padding:4px 8px;border-radius:8px;background:#173448;font-size:.85rem}
  .money{font-weight:700;color:#FFE8A3}
  .small{font-size:.9rem;color:#97adbb}
  .hidden{display:none!important}
  .list{list-style:none;margin:0;padding:0}
  .list li{padding:8px 0;border-bottom:1px solid #183244}
  .list li:last-child{border-bottom:none}

  /* Selection: stats */
  .statRow{display:flex;gap:8px;align-items:center;margin-top:6px}
  .statBall{width:18px;height:18px;border-radius:50%;display:inline-block}
  .s-speed{background:#70d6ff}
  .s-stam{background:#ffd46b}
  .s-burst{background:#ff9bb5}
  .meter{flex:1;height:8px;background:#173649;border-radius:6px;border:1px solid #274c5f;overflow:hidden}
  .meter>span{display:block;height:100%;background:#70d6ff}
  .meter.stam>span{background:#ffd46b}
  .meter.burst>span{background:#ff9bb5}
  .odds{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
  .odds .chip{background:#123043;border:1px solid #274c5f;border-radius:999px;padding:6px 10px}

  /* Race shell */
  .race-shell{position:relative;height:74vh;min-height:520px;border-radius:16px;overflow:hidden;background:#0A1D2A;border:1px solid #1f3d50}
  .trackWrap{position:absolute;inset:0;display:flex;flex-direction:column}
  .viewport{position:relative;flex:1;overflow:hidden}
  .world{position:absolute;left:0;right:0;top:0;will-change:transform}
  .bg{position:absolute;left:12px;right:12px;top:0;bottom:0;border:1px solid #274a5e;border-radius:12px;background:var(--track)}
  /* Vertical lane guides (left->right columns) */
  .laneGuides{position:absolute;left:12px;right:12px;top:0;bottom:0;pointer-events:none}
  .laneGuides .laneLine{position:absolute;top:0;bottom:0;width:2px;background:#2a4c60;opacity:.55}
  /* Horizontal distance marks along the course */
  .splits{position:absolute;left:12px;right:12px;top:0;pointer-events:none}
  .split{position:absolute;left:0;right:0;height:2px;background:#214559;opacity:.5}
  .split label{position:absolute;right:6px;top:-10px;font-size:.75rem;color:#93b7c9}

  .finishLine{position:absolute;left:12px;right:12px;height:10px;background:repeating-linear-gradient(90deg,#eee 0 18px,#111 18px 36px);border:1px solid #223f51;border-left:none;border-right:none}

  /* Gate at the top */
  .gate{position:absolute;left:12px;right:12px;height:14px;background:repeating-linear-gradient(90deg,#eee 0 18px,#111 18px 36px);border-bottom:1px solid #223f51;transform-origin:top;transform:scaleY(1);transition:transform .35s ease}
  .gate.open{transform:scaleY(0)}

  /* Horse sprite + label */
  .horse{position:absolute;display:flex;align-items:center;gap:var(--label-gap);transform:translate(0,0)}
  .icon{width:var(--horse-w);height:var(--horse-h);border-radius:6px;box-shadow:0 0 0 2px rgba(0,0,0,.25) inset;animation:gallop .3s ease-in-out infinite alternate}
  @keyframes gallop{from{transform:translateY(0)}to{transform:translateY(-3px)}}
  .tag{background:#0f2a3a;border:1px solid #2b4d60;color:var(--ink);padding:6px 8px;border-radius:10px;font-weight:600;white-space:nowrap;display:flex;align-items:center;gap:8px}
  .pos{min-width:34px;text-align:center;border-radius:8px;background:#173448;border:1px solid #31576a;padding:2px 6px;font-weight:800}
  .icons{display:flex;align-items:center;gap:4px}
  .picon{width:18px;height:18px;border-radius:50%;display:inline-flex;align-items:center;justify-content:center;font-size:.65rem;color:#0e1b23;font-weight:900;border:1px solid rgba(0,0,0,.25)}

  .leaderGlow{filter:drop-shadow(0 0 10px rgba(212,61,61,.6))}
  .top1 .tag{border-color:#ffd46b}
  .top2 .tag{border-color:#d0be6b}
  .top3 .tag{border-color:#9bd4ff}

  /* Countdown overlay */
  .countdown{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:5;pointer-events:none;background:radial-gradient(circle at 50% 45%, rgba(10,25,35,.45), rgba(10,25,35,.8) 60%, rgba(10,25,35,.95))}
  .countText{font-size:12vmin;font-weight:800;color:#fff;text-shadow:0 2px 0 rgba(0,0,0,.35)}
  .countGo{font-size:9vmin;color:#FFE8A3}

  /* Winner toast during race */
  .toast{position:absolute;left:50%;top:14%;transform:translateX(-50%);background:#123a2a;border:1px solid #1e5a44;color:#dbffe9;padding:12px 16px;border-radius:12px;z-index:6;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .toast.hidden{display:none}

  /* Results */
  .winBanner{background:#0f2a3a;border:1px solid #2d556a;border-radius:14px;padding:12px;display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .winBadge{background:#1c7c4a;border:1px solid #2bb36d;color:#eafff4;border-radius:999px;padding:6px 10px;font-weight:800}
  .lossBadge{background:#5b1b1b;border:1px solid #a33131;color:#ffe4e4;border-radius:999px;padding:6px 10px;font-weight:800}

  /* Results focus: dim track chrome */
  .fadeTrack .laneGuides,.fadeTrack .splits{opacity:0;transition:opacity .6s ease}

  /* Photo finish zoom */
  .zooming .world{transition:transform .35s ease}

  /* Fixed footer controls on race screen */
  .raceFooter{position:fixed;left:0;right:0;bottom:0;background:linear-gradient(180deg,rgba(11,31,42,0),rgba(11,31,42,.96));padding:10px 14px 16px}
  .raceFooter .inner{max-width:1000px;margin:0 auto;display:flex;gap:8px}

  /* Confetti canvas */
  #confetti{position:fixed;inset:0;pointer-events:none;opacity:0;transition:opacity .5s ease}
  #confetti.show{opacity:1}
</style>
</head>
<body>
<div class="wrap">
  <header class="row" style="justify-content:space-between">
    <h1>Photo Finish</h1>
    <div class="pill">20s race • Local multiplayer</div>
  </header>

  <!-- Screen: Add Players -->
  <section id="screen-players" class="grid">
    <div class="card grid">
      <h2>Add Players</h2>
      <div class="row" style="align-items:center">
        <div class="kpi" style="flex:1">
          <div><div class="label">Starting balance</div><div class="money" id="startBalanceShow">1000</div></div>
          <input id="startBalance" class="input" type="number" min="100" step="50" value="1000" style="max-width:160px" />
        </div>
      </div>
      <div class="row">
        <input id="playerName" class="input" placeholder="Player name" style="flex:1" />
        <button id="addPlayer" class="cta">Add</button>
      </div>
      <div class="row">
        <button class="ghost quick" data-n="2">Quick add 2</button>
        <button class="ghost quick" data-n="3">3</button>
        <button class="ghost quick" data-n="4">4</button>
        <button class="ghost quick" data-n="5">5</button>
        <button class="ghost quick" data-n="6">6</button>
      </div>
      <ul id="playerList" class="list"></ul>
      <div class="row">
        <button id="startGame" class="cta" disabled>Start Game</button>
        <button id="resetAll" class="ghost">Reset</button>
      </div>
    </div>
  </section>

  <!-- Screen: Selection -->
  <section id="screen-select" class="grid hidden">
    <div class="card grid">
      <h2>Horse Selection</h2>
      <div id="turnBanner" class="kpi">
        <div>
          <div class="label">Now selecting</div>
          <div id="currentPlayerName" style="font-weight:700"></div>
        </div>
        <div class="money">Balance: <span id="currentPlayerBalance">0</span></div>
      </div>
      <div class="row small" style="gap:14px">
        <div><span class="statBall s-speed"></span> Speed: base pace</div>
        <div><span class="statBall s-stam"></span> Stamina: mid-race hold</div>
        <div><span class="statBall s-burst"></span> Burst: late kick</div>
      </div>
    </div>

    <div class="card grid">
      <h3>Horses</h3>
      <div id="horseGrid" class="grid" style="grid-template-columns:repeat(auto-fill,minmax(270px,1fr));gap:10px"></div>
    </div>

    <div class="card grid">
      <h3>Bet</h3>
      <div class="row">
        <select id="betType" class="input" style="max-width:180px">
          <option value="win">Win</option>
          <option value="place">Place (Top 3)</option>
        </select>
        <input id="betAmount" class="input" type="number" min="1" step="10" value="50" style="max-width:160px" />
        <button id="lockPick" class="cta" style="flex:1" disabled>Lock Pick</button>
      </div>
      <div id="pickPreview" class="small"></div>
    </div>

    <div class="card">
      <h3>Summary</h3>
      <ul id="pickList" class="list"></ul>
      <div class="row">
        <button id="beginRace" class="cta" disabled>Start Race</button>
        <button id="backToPlayers" class="ghost">Back</button>
      </div>
    </div>
  </section>

  <!-- Screen: Race -->
  <section id="screen-race" class="grid hidden">
    <div class="card">
      <h2>Race</h2>
      <div class="small">Top to bottom • Camera follows the leader • ~20s</div>
    </div>

    <div id="raceShell" class="race-shell">
      <div id="toast" class="toast hidden">We have a winner!</div>

      <div class="trackWrap">
        <div class="viewport" id="viewport">
          <div class="world" id="world">
            <div class="bg" id="bg"></div>
            <div class="laneGuides" id="laneGuides"></div>
            <div class="splits" id="splits"></div>
            <div id="finishLine" class="finishLine"></div>
            <div id="gate" class="gate"></div>
            <!-- horses injected -->
          </div>

          <!-- Countdown overlay -->
          <div class="countdown hidden" id="countdown"><div id="countNum" class="countText">3</div></div>
        </div>
      </div>
    </div>

    <div class="raceFooter">
      <div class="inner">
        <button id="skipToResults" class="ghost" style="flex:1">Skip animation</button>
      </div>
    </div>
  </section>

  <!-- Screen: Results -->
  <section id="screen-results" class="grid hidden">
    <div id="roundBanner" class="winBanner hidden"></div>
    <div class="card grid"><h2>Results</h2><div id="podium" class="row"></div></div>
    <div class="card"><h3>Final Order</h3><ul id="orderList" class="list"></ul></div>
    <div class="card"><h3>Player Outcomes</h3><ul id="playerOutcomes" class="list"></ul></div>
    <div class="row">
      <button id="nextRound" class="cta">Next Race</button>
      <button id="leavePlayers" class="ghost">Remove Leavers</button>
      <button id="fullReset" class="ghost">Reset Game</button>
    </div>
  </section>
</div>

<!-- Confetti layer -->
<canvas id="confetti"></canvas>

<script>
/* ===========================
   Utility helpers
=========================== */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const clamp = (v,a,b) => Math.min(b,Math.max(a,v));
const rnd = (a,b) => Math.random()*(b-a)+a;
const rndi = (a,b) => Math.floor(rnd(a,b+1));
const fmt = n => Number(n).toLocaleString();
const esc = s => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
const ordinal = n => n===1?'1st':n===2?'2nd':n===3?'3rd':`${n}th`;
function shuffle(a){for(let i=a.length-1;i>0;i++){const j=rndi(0,i);[a[i],a[j]]=[a[j],a[i]]}return a;}
function groupBy(a,k){return a.reduce((m,o)=>((m[o[k]]??=[]).push(o),m),{});}
function randn(mu=0,s=1){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();const z=Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);return mu+z*s;}
const initials = name => name.split(/\s+/).map(w=>w[0]||'').join('').slice(0,2).toUpperCase();

/* ===========================
   Player palette (fixed)
=========================== */
const PLAYER_COLORS = ["#E879F9","#60A5FA","#34D399","#FBBF24","#F87171","#A78BFA"];

/* ===========================
   Lane spacing tuning (NEW)
=========================== */
const LANE_SPREAD = 1.15;       // widen lanes relative to calculated width
const MIN_LANE_GAP_MULT = 2.0;  // minimum gap = 2 × icon width

/* ===========================
   Embedded real horse names (200)
=========================== */
const REAL_NAMES = [
"Secretariat","Man o’ War","Seabiscuit","Citation","War Admiral","Affirmed","Alydar","Spectacular Bid","Sunday Silence","Easy Goer","Northern Dancer","Ruffian","Zenyatta","Black Caviar","Frankel","American Pharoah","Justify","Flightline","Arrogate","Curlin","Ghostzapper","Gun Runner","California Chrome","Winx","Phar Lap","Omaha","Whirlaway","Count Fleet","Gallant Fox","Native Dancer","Bold Ruler","Nashua","Kelso","Buckpasser","Forego","John Henry","Damascus","Dr. Fager","Alysheba","Cigar","Invasor","Peintre Celebre","Dancing Brave","Dubai Millennium","Sea The Stars","Galileo","Montjeu","Deep Impact","Harbinger","Enable","Tiger Roll","Red Rum","Desert Orchid","Kauto Star","Sprinter Sacre","Denman","Big Brown","Smarty Jones","Funny Cide","Barbaro","Rags to Riches","Lady’s Secret","Winning Colors","Genuine Risk","Serena’s Song","Personal Ensign","Beholder","Monomoy Girl","Rachel Alexandra","Havre de Grace","Blind Luck","Songbird","Tepin","Goldikova","Treve","Miesque","Dahlia","Ouija Board","Fantastic Light","Highland Reel","Crystal Ocean","Poet’s Word","Desert Crown","Hurricane Run","Almanzor","Sottsass","Vadeni","Paddington","Ace Impact","City of Troy","Auguste Rodin","Baaeed","Palace Pier","Pinatubo","Too Darn Hot","Blue Point","Lord Kanaloa","Lys Gracieux","Chrono Genesis","Almond Eye","Drefong","Nature Strip","Anamoe","Giga Kick","I Wish I Win","Verry Elleegant","Incentivise","Romantic Warrior","Golden Sixty","Beauty Generation","Able Friend","Silent Witness","Sacred Kingdom","Fairy King Prawn","Lucky Sweynesse","Wellington","Lucky Nine","Pakistan Star","Aerovelocity","Danon Smash","Satono Crown","Kizuna","Real Steel","Victoire Pisa","Just A Way","Orfevre","Buena Vista","Vodka","Daiwa Scarlet","Admire Moon","Heart’s Cry","King Kamehameha","El Condor Pasa","Agnes World","Agnes Digital","Eishin Preston","Stay Gold","Duramente","Contrail","Daring Tact","Loves Only You","Titleholder","Equinox","Liberty Island","Do Deuce","Stars on Earth","Songline","Schnell Meister","Gran Alegria","Indy Champ","Maurice","Harp Star","Gentildonna","Gold Ship","Epiphaneia","Le Vent Se Leve","Chuwa Wizard","T O Keynes","Ushba Tesoro","Panthalassa","Cafe Pharoah","Yoshida","Mind Your Biscuits","Lava Man","Game On Dude","Mucho Macho Man","Paynter","Bayern","Frosted","Honor Code","Tonalist","Palace Malice","Will Take Charge","Shackleford","Dullahan","Hansen","Union Rags","Orb","Palace Episode","Street Sense","Hard Spun","Any Given Saturday","Lawyer Ron","Quality Road","Animal Kingdom","Gio Ponti","Big Drama","Blame","Summer Bird","Mine That Bird","Da’ Tara","Proud Spell","Eight Belles","Dialed In","Always Dreaming","Tapwrit","Essential Quality","Epicenter","Forte","Goldikova II"
];

/* ===========================
   Global state
=========================== */
const state = {
  players: [],
  startBalance: 1000,
  round: 1,
  order: [],
  horses: [],
  picks: [],
  roundDeltas: [],
  race: {
    duration: 20000,        // ~20s
    trackDistance: 3200,    // px
    runoff: 110,
    t0: 0,
    raf: 0,
    started:false,
    finished:false,
    worldHeight:0,
    padTop:24,
    padBot:24,
    rankCounter:1,
    sprites:[],
    results:[]
  }
};

/* ===========================
   Screen helpers
=========================== */
const screens = {
  players: $('#screen-players'),
  select: $('#screen-select'),
  race: $('#screen-race'),
  results: $('#screen-results')
};
function show(k){
  Object.values(screens).forEach(s=>s.classList.add('hidden'));
  screens[k].classList.remove('hidden');
}

/* ===========================
   Players screen
=========================== */
const startBalance = $('#startBalance');
const startBalanceShow = $('#startBalanceShow');
const playerName = $('#playerName');
const playerList = $('#playerList');

$('#resetAll').onclick = fullReset;
$('#addPlayer').onclick = () => {
  const n = playerName.value.trim();
  if(!n) return;
  addPlayer(n);
  playerName.value='';
  renderPlayers();
};
$$('.quick').forEach(b => b.onclick = () => {
  const N = +b.dataset.n;
  const seeds = ["Alex","Sam","Casey","Jordan","Taylor","Riley","Jamie","Drew","Quinn","Harper"];
  while(state.players.length < N){
    addPlayer(seeds[state.players.length % seeds.length] + (state.players.length>=seeds.length ? ' '+(state.players.length+1) : ''));
  }
  renderPlayers();
});
startBalance.oninput = () => {
  const v = Math.max(100, +startBalance.value || 1000);
  state.startBalance = v;
  startBalanceShow.textContent = fmt(v);
};

function addPlayer(name){
  if(state.players.length>=6) return;
  const color = PLAYER_COLORS[state.players.length % PLAYER_COLORS.length];
  state.players.push({id:crypto.randomUUID(), name, balance:state.startBalance, active:true, color});
}
function removePlayer(id){
  state.players = state.players.filter(p=>p.id!==id);
}
function renderPlayers(){
  playerList.innerHTML = '';
  state.players.forEach(p=>{
    const li = document.createElement('li');
    li.innerHTML = `<div class="row" style="justify-content:space-between">
      <div class="row" style="gap:8px;align-items:center">
        <span style="width:14px;height:14px;border-radius:50%;display:inline-block;background:${p.color};border:1px solid rgba(0,0,0,.35)"></span>
        <strong>${esc(p.name)}</strong>
        <span class="badge">Balance: <span class="money">${fmt(p.balance)}</span></span>
      </div>
      <button class="ghost" data-id="${p.id}">Remove</button>
    </div>`;
    playerList.appendChild(li);
  });
  $$('#playerList .ghost').forEach(b=>b.onclick=()=>{removePlayer(b.dataset.id); renderPlayers();});

  $('#startGame').disabled = state.players.length < 2;
}
$('#startGame').onclick = () => {
  state.round = 1;
  startRound();
};
renderPlayers();

/* ===========================
   Selection screen
=========================== */
const turnBanner = $('#turnBanner');
const currentPlayerName = $('#currentPlayerName');
const currentPlayerBalance = $('#currentPlayerBalance');
const horseGrid = $('#horseGrid');
const pickList = $('#pickList');
const betType = $('#betType');
const betAmount = $('#betAmount');
const lockPick = $('#lockPick');
const beginRace = $('#beginRace');
$('#backToPlayers').onclick = () => show('players');

let turnIdx = 0, selHorseId = null;

function startRound(){
  state.picks = [];
  state.order = shuffle(state.players.filter(p=>p.active).map(p=>p.id));
  state.horses = genHorses(6);
  Object.assign(state.race, {finished:false, results:[], rankCounter:1, started:false});
  renderSelect();
  show('select');
  turnIdx = 0;
  prepTurn();
}

function genHorses(n){
  const laneColors = ['var(--lane1)','var(--lane2)','var(--lane3)','var(--lane4)','var(--lane5)','var(--lane6)'];
  const names = sampleNamesFromList(n);
  return Array.from({length:n}, (_,i) => {
    const speed = clamp(randn(0.65,0.15),0.35,1);
    const stamina = clamp(randn(0.65,0.15),0.35,1);
    const burst = clamp(randn(0.65,0.15),0.35,1);
    const q = speed*0.5 + stamina*0.3 + burst*0.2;
    const base = rnd(19.2,21.5) - (q-0.65)*2.0;
    const finishTime = clamp(base,18.8,22.5)*1000;
    const win = clamp(1.6+(1-q)*2.4+rnd(0,0.4),1.4,4.6);
    const place = clamp(win*rnd(0.5,0.7),1.2,Math.max(1.2,win*0.85));
    return {id:crypto.randomUUID(), name:names[i], color:laneColors[i], stats:{speed, stamina, burst, q}, finishTime, odds:{win, place}};
  });
}
function sampleNamesFromList(n){
  const pool=[...REAL_NAMES], out=[];
  while(out.length<n && pool.length){
    out.push(...pool.splice(rndi(0,pool.length-1),1));
  }
  return out.slice(0,n);
}

function renderSelect(){
  horseGrid.innerHTML = '';
  state.horses.forEach(h=>{
    const c=document.createElement('div'); c.className='card'; c.style.cursor='pointer'; c.dataset.hid=h.id;
    c.innerHTML = `
      <div class="row" style="align-items:flex-start;gap:10px">
        <div class="icon" style="width:36px;height:28px;background:${h.color};animation:none"></div>
        <div style="flex:1">
          <div style="font-weight:700">${esc(h.name)}</div>
          <div class="statRow"><span class="statBall s-speed"></span><div class="meter"><span style="width:${Math.round(h.stats.speed*100)}%"></span></div></div>
          <div class="statRow"><span class="statBall s-stam"></span><div class="meter stam"><span style="width:${Math.round(h.stats.stamina*100)}%"></span></div></div>
          <div class="statRow"><span class="statBall s-burst"></span><div class="meter burst"><span style="width:${Math.round(h.stats.burst*100)}%"></span></div></div>
          <div class="odds"><span class="chip">Win <strong>${h.odds.win.toFixed(2)}x</strong></span><span class="chip">Place <strong>${h.odds.place.toFixed(2)}x</strong></span></div>
        </div>
      </div>`;
    c.onclick = ()=>selectHorse(h.id);
    horseGrid.appendChild(c);
  });
  renderPicks();
}
function prepTurn(){
  if(turnIdx >= state.order.length){
    beginRace.disabled=false;
    turnBanner.classList.add('hidden');
    return;
  }
  beginRace.disabled=true;
  turnBanner.classList.remove('hidden');
  selHorseId = null;
  lockPick.disabled = true;
  const pid = state.order[turnIdx];
  const p = state.players.find(x=>x.id===pid);
  currentPlayerName.textContent = p.name;
  currentPlayerBalance.textContent = fmt(p.balance);
  betAmount.value = Math.min(100, p.balance);
  $('#pickPreview').textContent = '';
  $$('#horseGrid .card').forEach(e=>e.style.outline='1px solid #1e3a4a');
}
function selectHorse(id){
  selHorseId = id;
  $$('#horseGrid .card').forEach(e=>e.style.outline=(e.dataset.hid===id?'2px solid var(--red)':'1px solid #1e3a4a'));
  updatePreview();
}
function updatePreview(){
  const pid = state.order[turnIdx];
  const p = state.players.find(x=>x.id===pid);
  const amt = clamp(+betAmount.value||0,1,p.balance);
  betAmount.value = amt;
  if(!selHorseId){
    lockPick.disabled = true; $('#pickPreview').textContent='';
    return;
  }
  const h = state.horses.find(x=>x.id===selHorseId);
  const t = betType.value;
  const m = t==='win' ? h.odds.win : h.odds.place;
  $('#pickPreview').textContent = `${p.name} → ${h.name} • ${t.toUpperCase()} • ${fmt(amt)} @ ${m.toFixed(2)}x`;
  lockPick.disabled = false;
}
betType.onchange = updatePreview;
betAmount.oninput = updatePreview;

lockPick.onclick = () => {
  const pid = state.order[turnIdx];
  const p = state.players.find(x=>x.id===pid);
  const amt = clamp(+betAmount.value||0,1,p.balance);
  if(!selHorseId || amt<1) return;
  state.picks.push({playerId:p.id, horseId:selHorseId, type:betType.value, amount:amt});
  p.balance -= amt;
  turnIdx++;
  renderPicks();
  prepTurn();
};
function renderPicks(){
  pickList.innerHTML='';
  state.order.forEach(pid=>{
    const p = state.players.find(x=>x.id===pid);
    const pick = state.picks.find(x=>x.playerId===pid);
    const li=document.createElement('li');
    li.innerHTML = pick
      ? `<strong>${esc(p.name)}</strong> → <span class="pill">${esc(state.horses.find(x=>x.id===pick.horseId).name)}</span> • <span class="badge">${pick.type.toUpperCase()}</span> • <span class="money">${fmt(pick.amount)}</span>`
      : `<strong>${esc(p.name)}</strong> is choosing…`;
    pickList.appendChild(li);
  });
}

$('#beginRace').onclick = ()=>{ setupRace(); show('race'); beginCountdown(); };
$('#skipToResults').onclick = ()=>endRace(true);

/* ===========================
   Race scene setup
=========================== */
const viewport = $('#viewport');
const world = $('#world');
const laneGuides = $('#laneGuides');
const splits = $('#splits');
const bg = $('#bg');
const finishLine = $('#finishLine');
const gateEl = $('#gate');
const toast = $('#toast');
const countdownEl = $('#countdown');
const countNum = $('#countNum');
const confetti = $('#confetti');
const cfx = confetti.getContext('2d');

function setupRace(){
  // Clear world and rebuild chrome
  world.innerHTML = '';
  world.append(bg, laneGuides, splits, finishLine, gateEl);

  toast.classList.add('hidden');
  confetti.classList.remove('show');
  confetti.width = innerWidth;
  confetti.height = innerHeight;

  // World metrics
  const TD = state.race.trackDistance, padTop=state.race.padTop, padBot=state.race.padBot;
  const worldH = TD + padTop + padBot;
  state.race.worldHeight = worldH;

  world.style.height = worldH+'px';
  bg.style.top = '0px'; bg.style.height = worldH+'px';
  gateEl.style.top = padTop+'px';
  finishLine.style.top = (padTop + TD)+'px';

  // Horizontal distance marks
  splits.innerHTML='';
  [0.25,0.5,0.75].forEach(f=>{
    const y = padTop + TD*f;
    const s = document.createElement('div');
    s.className='split'; s.style.top = y+'px';
    const lab = document.createElement('label');
    lab.textContent = Math.round(f*100)+'%';
    s.appendChild(lab);
    splits.appendChild(s);
  });

  // Vertical lane guides: responsive lane spacing (FIXED)
  laneGuides.innerHTML='';
  const { leftPad, laneSpacing } = calcLaneGeometry();
  for(let i=0;i<=6;i++){
    const x = leftPad + i*laneSpacing;
    const g = document.createElement('div');
    g.className='laneLine'; g.style.left = x+'px';
    laneGuides.appendChild(g);
  }

  // Create horse sprites at the gate (top)
  state.race.sprites = state.horses.map((h,i)=>{
    const el = document.createElement('div'); el.className='horse'; el.dataset.hid = h.id;
    const iconW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--horse-w')) || 44;
    const x = leftPad + (i+1)*laneSpacing - iconW/2;
    el.style.left = x+'px';
    el.style.top = state.race.padTop+'px';

    const icon = document.createElement('div'); icon.className='icon'; icon.style.background=h.color;
    const tag = document.createElement('div'); tag.className='tag';
    tag.innerHTML = `<span class="pos" data-pos>—</span><span class="hName">${esc(h.name)}</span><span class="icons" data-icons></span>`;
    // Slightly larger horizontal offset (FIXED)
    tag.style.transform = `translateX(${(i%2===0?1:-1)*12}px)`;
    const icons = tag.querySelector('[data-icons]');
    el.append(icon, tag); world.appendChild(el);

    return {h, el, icon, tag, icons, y:0, crossed:false, offtrack:false, crossTime:null, rank:null, posEl:tag.querySelector('[data-pos]'),
            vBase: TD/(h.finishTime/1000), plan: pacePlan(h)};
  });

  // Player initials on each horse
  const byHorse = groupBy(state.picks,'horseId');
  state.race.sprites.forEach(S=>{
    S.icons.innerHTML='';
    const arr = byHorse[S.h.id] || [];
    arr.slice(0,4).forEach(pk=>{
      const p = state.players.find(pp=>pp.id===pk.playerId);
      const ic = document.createElement('span');
      ic.className='picon'; ic.textContent = initials(p.name); ic.style.background = p.color;
      S.icons.appendChild(ic);
    });
    if(arr.length>4){
      const more=document.createElement('span'); more.className='picon'; more.textContent=`+${arr.length-4}`; more.style.background='#b9d3e0';
      S.icons.appendChild(more);
    }
  });

  // Resize handler keeps lanes centered
  window.onresize = ()=>{
    const g = calcLaneGeometry();
    $$('#laneGuides .laneLine').forEach((line, idx)=>line.style.left = (g.leftPad + idx*g.laneSpacing)+'px');
    state.race.sprites.forEach((S,i)=>{
      const iconW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--horse-w')) || 44;
      const nx = g.leftPad + (i+1)*g.laneSpacing - iconW/2;
      S.el.style.left = nx+'px';
    });
  };
}

/* NEW: lane geometry uses real inner width, ensures minimum gap */
function calcLaneGeometry(){
  // Use the actual drawable width between the 12px insets
  const inner = document.getElementById('laneGuides').getBoundingClientRect().width;
  const iconW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--horse-w')) || 44;

  // Base spacing over 7 slots (6 lanes => 7 intervals), widened by LANE_SPREAD
  let spacing = (inner / 7) * LANE_SPREAD;

  // Enforce a minimum pixel gap per lane
  spacing = Math.max(spacing, iconW * MIN_LANE_GAP_MULT);

  // Clamp so 7 intervals still fit the inner width
  if (spacing * 7 > inner) spacing = inner / 7;

  const leftPad = 12; // aligns with bg inset
  return {leftPad, laneSpacing: spacing};
}

function pacePlan(h){
  const T = h.finishTime;
  const stops = [0,5000,10000,15000,Math.max(18500,T-2500),T];
  const mul = Array(stops.length-1).fill(0).map(()=>rnd(0.94,1.06));
  const a=rndi(1,3), b=rndi(2,4);
  mul[a]*=rnd(1.10,1.22); // random mid surge
  mul[b]*=rnd(1.08,1.18); // late move
  mul[2]*=(0.94+h.stats.stamina*0.12); // stamina helps mid
  return {stops,mul};
}
function seg(stops,t){for(let i=0;i<stops.length-1;i++){if(t>=stops[i]&&t<stops[i+1])return i}return stops.length-2}

/* ===========================
   Countdown and race start
=========================== */
function beginCountdown(){
  countdownEl.classList.remove('hidden');
  countNum.className='countText';
  let n=3;
  countNum.textContent = n;
  const tick = ()=>{
    n--;
    if(n>0){
      countNum.textContent = n;
      setTimeout(tick,1000);
    }else{
      countNum.textContent = 'GO!';
      countNum.className='countGo';
      playGates();
      setTimeout(()=>{
        countdownEl.classList.add('hidden');
        startRace();
      },320);
    }
  };
  setTimeout(tick,1000);
}

/* ===========================
   Audio (generated as Base64 WAV at runtime)
=========================== */
let gallopAudio, cheerAudio, gatesAudio;

function makeWavBase64FromFloat32(samples, sampleRate=22050, numChannels=1){
  const buffer = new ArrayBuffer(44 + samples.length*2);
  const view = new DataView(buffer);
  function writeString(off, s){for(let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));}
  writeString(0,'RIFF');
  view.setUint32(4,36 + samples.length*2, true);
  writeString(8,'WAVE');
  writeString(12,'fmt ');
  view.setUint32(16,16,true);
  view.setUint16(20,1,true);
  view.setUint16(22,numChannels,true);
  view.setUint32(24,sampleRate,true);
  view.setUint32(28,sampleRate*numChannels*2,true);
  view.setUint16(32,numChannels*2,true);
  view.setUint16(34,16,true);
  writeString(36,'data');
  view.setUint32(40,samples.length*2,true);
  let idx=44;
  for(let i=0;i<samples.length;i++){
    const s = Math.max(-1,Math.min(1,samples[i]));
    view.setInt16(idx, s<0 ? s*0x8000 : s*0x7FFF, true);
    idx+=2;
  }
  let binary='';
  const bytes = new Uint8Array(buffer);
  for(let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function buildGateSound(){
  const sr=22050, dur=0.25, N=Math.floor(sr*dur);
  const data = new Float32Array(N);
  for(let i=0;i<N;i++){
    const t=i/sr;
    const env = Math.exp(-12*t);
    const freq = 140 + 60*Math.exp(-8*t);
    data[i] = env * Math.sin(2*Math.PI*freq*t);
  }
  const b64 = makeWavBase64FromFloat32(data, sr, 1);
  return new Audio('data:audio/wav;base64,'+b64);
}
function buildGallopLoop(){
  const sr=22050, dur=0.6, N=Math.floor(sr*dur);
  const data = new Float32Array(N);
  const beats=[0.00,0.12,0.24,0.40];
  for(let i=0;i<N;i++){
    const t=i/sr;
    let v=0;
    for(const b of beats){
      const dt = (t-b+dur)%dur;
      const env = Math.exp(-60*dt);
      v += env * Math.sin(2*Math.PI*110*t) * 0.45;
    }
    v += 0.08*Math.sin(2*Math.PI*55*t);
    data[i]=v*0.8;
  }
  const b64 = makeWavBase64FromFloat32(data, sr, 1);
  const a = new Audio('data:audio/wav;base64,'+b64);
  a.loop = true;
  return a;
}
function buildCheer(){
  const sr=22050, dur=1.8, N=Math.floor(sr*dur);
  const data = new Float32Array(N);
  let r=1;
  for(let i=0;i<N;i++){
    const t=i/sr;
    r = (r*16807)%2147483647;
    const n = (r/2147483647)*2-1;
    const env = Math.min(1, Math.max(0, 1.2*Math.exp(-1.2*(t-0.2))));
    const tone = 0.15*Math.sin(2*Math.PI*(220+20*Math.sin(2*Math.PI*1.5*t))*t);
    data[i] = 0.6*n*env + tone*env;
  }
  const b64 = makeWavBase64FromFloat32(data, sr, 1);
  return new Audio('data:audio/wav;base64,'+b64);
}
function ensureAudio(){
  if(!gatesAudio) gatesAudio = buildGateSound();
  if(!gallopAudio) gallopAudio = buildGallopLoop();
  if(!cheerAudio) cheerAudio = buildCheer();
}
function playGates(){ ensureAudio(); try{gatesAudio.currentTime=0; gatesAudio.play();}catch{} }
function playGallop(){ ensureAudio(); try{gallopAudio.currentTime=0; gallopAudio.play();}catch{} }
function stopGallop(){ try{gallopAudio.pause();}catch{} }
function playCheer(){ ensureAudio(); try{cheerAudio.currentTime=0; cheerAudio.play();}catch{} }

/* ===========================
   Race animation
=========================== */
let camY=0, lastTs=0, winnerAnnounced=false, slowMo=false, zoomFocusY=0;

function startRace(){
  gateEl.classList.add('open');
  state.race.t0 = performance.now();
  state.race.finished = false;
  state.race.started = true;
  winnerAnnounced = false;
  slowMo = false;
  playGallop();

  const vpH = viewport.clientHeight;
  const maxCam = Math.max(0, state.race.worldHeight - vpH);
  camY = 0; world.style.transform = `translateY(${-camY}px)`;
  lastTs = state.race.t0;

  function frame(now){
    const t = now - state.race.t0;
    let dt = (now - lastTs)/1000; if(dt>0.06) dt=0.06; lastTs = now;

    // Slow-mo near finish if close
    const TD = state.race.trackDistance;
    const leaderDist = Math.max(...state.race.sprites.map(S=>S.y));
    const pack = [...state.race.sprites].sort((a,b)=>b.y-a.y);
    if(!slowMo && leaderDist > TD*0.92){
      const d12 = (pack[0]?.y||0) - (pack[1]?.y||0);
      if(d12 < 45){ // close finish
        slowMo = true;
        document.getElementById('raceShell').classList.add('zooming');
        zoomFocusY = state.race.padTop + TD;
      }
    }
    if(slowMo){ dt *= 0.35; }

    let allOff = true;

    // Advance horses
    for(const S of state.race.sprites){
      if(S.offtrack) continue;
      const i = seg(S.plan.stops, t);
      let v = S.vBase * S.plan.mul[i];
      v *= (1 + 0.02*Math.sin((t/1000)*(1.2+S.h.stats.burst*1.6)));
      S.y += v*dt;

      // tighten finish ETA
      const lastI = S.plan.stops.length-2;
      if(i===lastI){
        const rt = (S.h.finishTime - t)/1000, rd = TD - S.y;
        if(rt>0){
          v = v*0.5 + (rd/rt)*0.5;
          S.y += v*dt;
        }
      }

      if(!S.crossed && S.y >= TD){
        S.crossed = true;
        S.crossTime = t;
        S.rank = state.race.rankCounter++;
        state.race.results.push({horseId:S.h.id, finishTime:S.crossTime, rank:S.rank});
        if(S.rank===1 && !winnerAnnounced){
          winnerAnnounced = true;
          toast.textContent = `${S.h.name} hits the line first!`;
          toast.classList.remove('hidden');
          setTimeout(()=>toast.classList.add('hidden'), 2200);
        }
      }

      if(S.y >= TD + state.race.runoff){
        S.y = TD + state.race.runoff;
        S.offtrack = true;
      }else{
        allOff = false;
      }

      S.el.style.transform = `translate(0, ${S.y}px)`;
    }

    // Live positions, badges, leader glow
    const live = [...state.race.sprites].sort((a,b)=>b.y-a.y);
    state.race.sprites.forEach(S=>S.el.classList.remove('top1','top2','top3','leaderGlow'));
    live.forEach((S,i)=>{
      if(i===0) S.el.classList.add('top1','leaderGlow');
      else if(i===1) S.el.classList.add('top2');
      else if(i===2) S.el.classList.add('top3');
      S.posEl.textContent = ordinal(i+1);
    });

    // Camera follows leader
    const leader = live[0];
    const leaderWorldY = state.race.padTop + leader.y;
    const target = clamp(leaderWorldY - vpH*0.60, 0, maxCam);
    camY += (target - camY) * 0.14;

    const leaderScreenY = leaderWorldY - camY;
    if(leaderScreenY < vpH*0.35) camY = clamp(leaderWorldY - vpH*0.35, 0, maxCam);
    if(leaderScreenY > vpH*0.75) camY = clamp(leaderWorldY - vpH*0.75, 0, maxCam);

    const zoom = slowMo ? 1.08 : 1;
    world.style.transform = `translateY(${-camY}px) scale(${zoom})`;
    world.style.transformOrigin = `50% ${zoomFocusY - camY}px`;

    if(allOff || t >= state.race.duration + 4000){
      endRace(false);
      return;
    }
    state.race.raf = requestAnimationFrame(frame);
  }
  state.race.raf = requestAnimationFrame(frame);
}

/* ===========================
   End race, settle, results
=========================== */
const roundBanner = $('#roundBanner');
const podium = $('#podium');
const orderList = $('#orderList');
const playerOutcomes = $('#playerOutcomes');

function endRace(skip){
  if(state.race.finished) return;
  state.race.finished = true;
  if(state.race.raf) cancelAnimationFrame(state.race.raf);
  stopGallop();

  const TD = state.race.trackDistance;

  if(skip){
    const order=[...state.race.sprites].sort((a,b)=>b.y-a.y);
    order.forEach((S,i)=>{
      if(!S.crossed){
        S.crossed = true;
        S.crossTime = 20000 + i*100;
        S.rank = state.race.rankCounter++;
        state.race.results.push({horseId:S.h.id, finishTime:S.crossTime, rank:S.rank});
      }
      S.y = TD + state.race.runoff; S.offtrack=true; S.el.style.transform=`translate(0, ${S.y}px)`;
    });
  }else{
    const remain = state.race.sprites.filter(s=>!s.crossed).sort((a,b)=>b.y-a.y);
    if(remain.length){
      const base=(state.race.results.at(-1)?.finishTime)||20000;
      remain.forEach((S,i)=>{
        S.crossed = true;
        S.crossTime = base+100+i*50;
        S.rank = state.race.rankCounter++;
        state.race.results.push({horseId:S.h.id, finishTime:S.crossTime, rank:S.rank});
        S.y = TD + state.race.runoff; S.offtrack=true; S.el.style.transform=`translate(0, ${S.y}px)`;
      });
    }
  }

  $('#raceShell').classList.add('fadeTrack');

  settle();
  renderResults();

  const winnerId = state.race.results.sort((a,b)=>a.rank-b.rank)[0].horseId;
  const someBacked = state.picks.some(pk => pk.horseId===winnerId && (pk.type==='win' || pk.type==='place'));
  if(someBacked){
    playCheer();
    runConfetti(5000);
  }

  show('results');
}

function settle(){
  const order = [...state.race.results].sort((a,b)=>a.rank-b.rank).map(r=>r.horseId);
  const first = order[0];
  const top3 = new Set(order.slice(0,3));

  state.roundDeltas = state.players.map(p=>({playerId:p.id,name:p.name,color:p.color,won:0,staked:0,net:0,wonOn:[]}));

  state.picks.forEach(pk=>{
    const h = state.horses.find(x=>x.id===pk.horseId);
    const p = state.players.find(x=>x.id===pk.playerId);
    const rec = state.roundDeltas.find(r=>r.playerId===p.id);
    rec.staked += pk.amount;

    let win=0;
    if(pk.type==='win' && pk.horseId===first){ win=pk.amount*h.odds.win; rec.wonOn.push(h.name);}
    else if(pk.type==='place' && top3.has(pk.horseId)){ win=pk.amount*h.odds.place; rec.wonOn.push(h.name);}
    if(win>0){ const w=Math.floor(win); p.balance += w; rec.won += w; }
    pk.win = Math.floor(win);
    pk.result = win>0?'WIN':'LOSE';
  });
  state.roundDeltas.forEach(r=>{r.net=r.won-r.staked;});
}

$('#nextRound').onclick = ()=>{ state.round++; startRound(); };
$('#leavePlayers').onclick = ()=>{
  state.players = state.players.filter(p=>p.active && p.balance>0);
  if(state.players.length<2){ alert('Not enough players.'); fullReset(); return; }
  state.round++; startRound();
};
$('#fullReset').onclick = fullReset;

function renderResults(){
  const ord=[...state.race.results].sort((a,b)=>a.rank-b.rank);
  const winnerHorse = state.horses.find(h=>h.id===ord[0].horseId);
  const winners = state.roundDeltas.filter(r=>r.wonOn.includes(winnerHorse.name));
  const topNet = [...state.roundDeltas].sort((a,b)=>b.net-a.net)[0];

  roundBanner.classList.remove('hidden');
  roundBanner.innerHTML = `
    <span class="winBadge">Winner: ${esc(winnerHorse.name)}</span>
    ${winners.length
      ? winners.map(w=>`<span class="winBadge" style="background:#1f6b3c;border-color:#2da760">+${fmt(w.net>0?w.net:w.won)} ${esc(w.name)}</span>`).join('')
      : `<span class="lossBadge">No winning tickets</span>`}
    <span class="${topNet.net>=0?'winBadge':'lossBadge'}">Top net: ${esc(topNet.name)} ${topNet.net>=0?'+':''}${fmt(topNet.net)}</span>
  `;

  podium.innerHTML='';
  const medals=['🥇','🥈','🥉'];
  ord.slice(0,3).forEach((o,i)=>{
    const h=state.horses.find(x=>x.id===o.horseId);
    const d=document.createElement('div'); d.className='kpi';
    d.innerHTML=`<div class="row" style="gap:8px"><span style="font-size:1.25rem">${medals[i]}</span><div class="icon" style="width:18px;height:14px;background:${h.color};animation:none"></div><strong>${esc(h.name)}</strong></div><div class="small">Time: ${(o.finishTime/1000).toFixed(2)}s</div>`;
    podium.appendChild(d);
  });

  orderList.innerHTML='';
  ord.forEach((o)=>{
    const h = state.horses.find(x=>x.id===o.horseId);
    const bettors = state.picks.filter(pk=>pk.horseId===o.horseId).map(pk=>state.players.find(p=>p.id===pk.playerId).name);
    const li=document.createElement('li');
    li.innerHTML=`<div class="row" style="justify-content:space-between">
      <div class="row" style="gap:8px">
        <div class="badge">#${o.rank}</div>
        <div class="icon" style="width:18px;height:14px;background:${h.color};animation:none"></div>
        <strong>${esc(h.name)}</strong>
      </div>
      <div class="small">${bettors.length?('Picked by: '+bettors.map(esc).join(', ')):'No picks'}</div>
    </div>`;
    orderList.appendChild(li);
  });

  // Player outcomes
  playerOutcomes.innerHTML='';
  const by=groupBy(state.picks,'playerId');
  state.players.forEach(p=>{
    const arr=by[p.id]||[];
    const delta=state.roundDeltas.find(d=>d.playerId===p.id) || {net:0};
    const rows = arr.length ? arr.map(pk=>{
      const h=state.horses.find(x=>x.id===pk.horseId);
      return `<div class="row" style="justify-content:space-between">
        <div>${pk.type.toUpperCase()} • <span class="pill">${esc(h.name)}</span> • <span class="small">${fmt(pk.amount)} bet</span></div>
        <div class="${pk.win>0?'money':''}">${pk.result} ${pk.win>0?('+ '+fmt(pk.win)):' '}</div>
      </div>`;
    }).join('') : `<div class="small">No bets this round.</div>`;
    const li=document.createElement('li');
    li.innerHTML = `<div class="row" style="justify-content:space-between">
      <div class="row" style="gap:8px">
        <span style="width:14px;height:14px;border-radius:50%;display:inline-block;background:${p.color};border:1px solid rgba(0,0,0,.35)"></span>
        <strong>${esc(p.name)}</strong>
      </div>
      <div>Balance: <span class="money">${fmt(p.balance)}</span> <span class="${delta.net>=0?'winBadge':'lossBadge'}" style="margin-left:6px">${delta.net>=0?'+':''}${fmt(delta.net)}</span></div>
    </div>
    <div class="card" style="margin-top:8px">${rows}</div>`;
    playerOutcomes.appendChild(li);
  });
}

/* ===========================
   Confetti (5s then fade)
=========================== */
let confettiTimer=null, confettiAnim=null, parts=[];
function runConfetti(ms=5000){
  parts = Array.from({length:220}, ()=>({
    x: Math.random()*confetti.width,
    y: Math.random()*-confetti.height,
    r: Math.random()*6+3,
    vy: Math.random()*2+2,
    vx: (Math.random()-0.5)*1.2,
    a: Math.random()*360,
    va: (Math.random()-0.5)*8,
    color: `hsl(${Math.random()*360},100%,50%)`
  }));
  confetti.classList.add('show');
  const step = ()=>{
    cfx.clearRect(0,0,confetti.width,confetti.height);
    for(const p of parts){
      p.x += p.vx; p.y += p.vy; p.a += p.va;
      if(p.y > confetti.height+20) { p.y = -10; p.x = Math.random()*confetti.width; }
      cfx.save();
      cfx.translate(p.x,p.y);
      cfx.rotate(p.a*Math.PI/180);
      cfx.fillStyle = p.color;
      cfx.fillRect(-p.r/2,-p.r/2,p.r,p.r);
      cfx.restore();
    }
    confettiAnim = requestAnimationFrame(step);
  };
  step();
  clearTimeout(confettiTimer);
  confettiTimer = setTimeout(()=>{
    confetti.classList.remove('show');
    if(confettiAnim) cancelAnimationFrame(confettiAnim);
  }, ms);
}

/* ===========================
   Controls: results and reset
=========================== */
function fullReset(){
  state.players=[]; state.round=1; state.order=[]; state.horses=[]; state.picks=[];
  state.race = {duration:20000, trackDistance:3200, runoff:110, t0:0, raf:0, started:false, finished:false, worldHeight:0, padTop:24, padBot:24, rankCounter:1, sprites:[], results:[]};
  renderPlayers(); show('players');
}

/* ===========================
   Wire race buttons
=========================== */
$('#fullReset').onclick = fullReset;

/* ===========================
   Kickoff helpers for first load
=========================== */
renderPlayers();

/* ===========================
   END
=========================== */
</script>
</body>
</html>


